// Generates helper functions for executing combinators that take $arg_count number of arguments to evaluate.
macro_rules! run_comb {
    ($name:ident, $arg_count:literal) => {
        // pub(super) because these functions belong to the engine, but they are instantiated in an autogenerated submodule.
        pub(super) fn $name<F: FnOnce(&mut TurnerEngine, [CellPtr; $arg_count]) -> StepResult>(
            &mut self,
            handler: F,
        ) -> Option<CellPtr> {
            const FRAME_SIZE: usize = $arg_count + 1;
            debug_assert!(self.stack.len() >= FRAME_SIZE);
            // Arguments are in reverse order because the stack is LIFO.
            let mut args = [CellPtr(0); $arg_count];
            for i in 0..$arg_count {
                args[i] = *unsafe { self.stack.get_unchecked(self.stack.len() - 2 - i) };
            }
            let frame_start = args[$arg_count - 1];

            match handler(self, args) {
                StepResult::Value(v) => {
                    // Make an indirection node
                    self.set_tag(frame_start, Tag::wanted().set_rhs_int());
                    self.set_hd(frame_start, COMB_I);
                    self.set_tl(frame_start, CellPtr(v));

                    // If nothing is on the stack, return the node
                    if self.stack.len() == FRAME_SIZE {
                        return Some(frame_start);
                    }
                    // Remove this frame, returning to the parent expression on the stack
                    unsafe { self.stack.set_len(self.stack.len() - FRAME_SIZE) };
                    None
                }
                StepResult::Cell(c) => {
                    // Make an indirection node
                    self.set_tag(frame_start, Tag::wanted());
                    self.set_hd(frame_start, COMB_I);
                    self.set_tl(frame_start, c);

                    // Make the new cell top of the stack
                    let new_len = self.stack.len() - $arg_count;
                    unsafe {
                        *self.stack.get_unchecked_mut(new_len - 1) = c;
                        self.stack.set_len(new_len);
                    }
                    None
                }
                StepResult::CellContents(tag, hd, tl) => {
                    // Create the new cell over the old one
                    self.set_tag(frame_start, tag);
                    self.set_hd(frame_start, hd);
                    self.set_tl(frame_start, tl);

                    // Make the new cell top of the stack
                    let new_len = self.stack.len() - $arg_count;
                    unsafe {
                        self.stack.set_len(new_len);
                    }
                    None
                }
                StepResult::EvaluateArg(a) => {
                    self.stack.push(a);
                    None
                }
                StepResult::EvaluateArg2(a, b) => {
                    self.stack.push(a);
                    self.stack.push(b);
                    None
                }
            }
        }
    };
}
// See https://stackoverflow.com/questions/74586162/how-to-import-use-macro-from-different-module-in-the-same-crate.
pub(crate) use run_comb;

macro_rules! run_sn_comb {
    ($name:ident, $run_combn:ident) => {
        pub(super) fn $name(&mut self) -> Option<CellPtr> {
            self.$run_combn(|engine, args| {
                // S f g x => f x (g x)
                let f = engine.tl(args[0]);
                let g = engine.tl(args[1]);

                let mut left_cell = f;
                let mut right_cell = g;
                for arg in &args[2..] {
                    let x = engine.tl(*arg);
                    // If x is an int, we should transfer that to the new location
                    let mut tag = Tag::wanted();
                    if engine.tag(*arg).is_rhs_int() {
                        tag = tag.set_rhs_int();
                    }

                    // Add the extra argument to both branches
                    left_cell = engine.make_cell(tag, left_cell, x);
                    right_cell = engine.make_cell(tag, right_cell, x);
                }
                StepResult::CellContents(Tag::wanted(), left_cell, right_cell)
            })
        }
    };
}
pub(crate) use run_sn_comb;

macro_rules! run_bn_comb {
    ($name:ident, $run_combn:ident) => {
        pub(super) fn $name(&mut self) -> Option<CellPtr> {
            self.$run_combn(|engine, args| {
                // B f g x => f (g x)
                let f = engine.tl(args[0]);
                let g = engine.tl(args[1]);

                let mut right_cell = g;
                for arg in &args[2..] {
                    let x = engine.tl(*arg);
                    // If x is an int, we should transfer that to the new location
                    let mut tag = Tag::wanted();
                    if engine.tag(*arg).is_rhs_int() {
                        tag = tag.set_rhs_int();
                    }

                    // Add the extra argument to the right branch
                    right_cell = engine.make_cell(tag, right_cell, x);
                }
                StepResult::CellContents(Tag::wanted(), f, right_cell)
            })
        }
    };
}
pub(crate) use run_bn_comb;

macro_rules! run_cn_comb {
    ($name:ident, $run_combn:ident) => {
        pub(super) fn $name(&mut self) -> Option<CellPtr> {
            self.$run_combn(|engine, args| {
                // C f g x => f x g
                let f = engine.tl(args[0]);
                let g = engine.tl(args[1]);

                let mut left_cell = f;
                for arg in &args[2..] {
                    let x = engine.tl(*arg);
                    // If x is an int, we should transfer that to the new location
                    let mut tag = Tag::wanted();
                    if engine.tag(*arg).is_rhs_int() {
                        tag = tag.set_rhs_int();
                    }

                    // Add the extra argument to both branches
                    left_cell = engine.make_cell(tag, left_cell, x);
                }
                // If g is an int, we should transfer that to the new location
                let mut tag = Tag::wanted();
                if engine.tag(args[1]).is_rhs_int() {
                    tag = tag.set_rhs_int();
                }
                StepResult::CellContents(tag, left_cell, g)
            })
        }
    };
}
pub(crate) use run_cn_comb;
